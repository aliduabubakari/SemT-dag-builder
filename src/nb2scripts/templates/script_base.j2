#!/usr/bin/env python3
"""
{{ script.name }}.py - Auto-generated script
Generated: {{ timestamp.strftime('%Y-%m-%d %H:%M:%S') }}

Operations:
{%- for op in operations %}
  {{ loop.index }}. {{ op.op_type }}: {{ op.name }}
{%- endfor %}
"""

import os
import sys
import json
import logging
import datetime
import pandas as pd
from typing import Optional, Dict, Any

# Ensure 'scripts' package is importable when running directly
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PARENT_DIR = os.path.dirname(SCRIPT_DIR)
if PARENT_DIR not in sys.path:
    sys.path.insert(0, PARENT_DIR)

from scripts.utils.file_utils import PipelineFileManager

from semt_py.auth_manager import AuthManager
from semt_py.reconciliation_manager import ReconciliationManager
from semt_py.extension_manager import ExtensionManager
from semt_py.utils import Utility
from semt_py.dataset_manager import DatasetManager
from semt_py.table_manager import TableManager
from semt_py.modification_manager import ModificationManager

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class Config:
    """Pipeline configuration from environment."""
    def __init__(self):
        base_url = os.environ.get('API_BASE_URL', 'http://localhost:3003')
        self.auth_api_url = f"{base_url}/api"
        self.table_base_url = base_url

        self.username = os.environ.get('API_USERNAME', 'test')
        self.password = os.environ.get('API_PASSWORD', 'test')

        # Input/Output
        self.input_file_path = os.environ.get('INPUT_FILE_PATH')
        self.input_json_path = os.environ.get('INPUT_JSON_PATH')  # used by non-load stages via XCom
        self.data_dir = os.environ.get('DATA_DIR', '/app/data')

        # Backend
        self.dataset_id = os.environ.get('DATASET_ID', '5')
        self.table_id = os.environ.get('TABLE_ID')
        self.table_name = os.environ.get('TABLE_NAME', '').strip()

        # Run meta
        self.run_id = os.environ.get('RUN_ID', datetime.datetime.now().strftime('%Y%m%d_%H%M%S'))
        self.stage_name = os.environ.get('STAGE_NAME', '{{ script.name }}')
        self.stage_number = int(os.environ.get('STAGE_NUMBER', '{{ script.stage }}'))

        logger.info(f"{'='*60}")
        logger.info(f"STAGE: {self.stage_name} (#{self.stage_number})")
        logger.info(f"Run ID: {self.run_id}")
        logger.info(f"{'='*60}")


{# All operation functions are injected below #}
{%- for op in operations %}
{{ op.rendered_template }}

{% endfor %}

def run_{{ script.safe_name }}(config: Config):
    """Main execution function for {{ script.name }}."""
    logger.info(f"üöÄ Starting {{ script.name }}")

    # Initialize local state manager
    file_manager = PipelineFileManager(config.data_dir, config.run_id)

    # Execute operations in sequence
    results = []
{% for op in operations %}
    logger.info(f"{'='*60}")
    result_{{ loop.index }} = run_{{ op.op_type | lower }}_operation_{{ loop.index }}(config, file_manager)
    results.append(result_{{ loop.index }})
{% endfor %}

    logger.info(f"{'='*60}")
    logger.info(f"‚úÖ {{ script.name }} completed successfully!")
    logger.info(f"üîÑ Output: {file_manager.get_current_file_path()}")

    return file_manager.get_current_file_path()


def main():
    """Entry point."""
    exit_code = 1
    output_path = None
    try:
        config = Config()
        output_path = run_{{ script.safe_name }}(config)
        exit_code = 0
    except Exception as e:
        logger.exception(f"‚ùå Error in {{ script.name }}: {e}")
    finally:
        # Print output path for Airflow XCom
        if output_path and exit_code == 0:
            print(output_path)
    sys.exit(exit_code)


if __name__ == "__main__":
    main()